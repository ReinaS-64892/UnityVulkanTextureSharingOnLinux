// use ash::khr::{surface, surface_protected_capabilities, swapchain};
// use ash::vk::{self, SwapchainCreateInfoKHR};
// use rustix::process::{ForeignRawFd, Pid, PidfdFlags, PidfdGetfdFlags};
// use std::error::Error;
// use std::ffi::CStr;
// use winit::dpi::{PhysicalSize, Size};
// use winit::event_loop::{ActiveEventLoop, ControlFlow};
// use winit::raw_window_handle::{HasDisplayHandle, HasWindowHandle};
// use winit::{application::ApplicationHandler, event::WindowEvent, event_loop::EventLoop};

// fn main() -> Result<(), Box<dyn Error>> {
//     println!("ねこ!");
//     // let fd = get_fd_from_args();

//     let mut app = App::new();
//     let event_loop = EventLoop::builder().build()?;
//     event_loop.set_control_flow(ControlFlow::Wait);
//     event_loop.run_app(&mut app).unwrap();
//     Ok(())
// }

// #[derive(Debug)]
// struct App {
//     window: Option<winitWindow>,
//     surface: Option<vk::SurfaceKHR>,
// }
// impl App {
//     fn new() -> Self {
//         Self {
//             window: None,
//             surface: None,
//         }
//     }
// }

// impl ApplicationHandler for App {
//     fn resumed(&mut self, event_loop: &winit::event_loop::ActiveEventLoop) {
//         let window_size = Size::Physical(PhysicalSize::new(1024, 1024));
//         let window_attributes = winitWindow::default_attributes()
//             .with_title("Winit window なのだ")
//             .with_transparent(false)
//             .with_inner_size(window_size);
//         // let fd = get_fd_from_args();
//         println!("resumed!!!");
//         let new_window = event_loop.create_window(window_attributes).unwrap();

//         unsafe {
//             let display_handle = event_loop.display_handle().unwrap();
//             let window_handle = new_window.window_handle().unwrap();

//             let entry = ash::Entry::load().unwrap();
//             let req_window_ext =
//                 ash_window::enumerate_required_extensions(display_handle.as_raw()).unwrap();
//             let app_info =
//                 vk::ApplicationInfo::default().api_version(vk::make_api_version(0, 1, 1, 0));
//             let instance_info = vk::InstanceCreateInfo::default()
//                 .application_info(&app_info)
//                 .enabled_extension_names(req_window_ext);

//             let instance = entry.create_instance(&instance_info, None).unwrap();

//             let physical_device = *instance
//                 .enumerate_physical_devices()
//                 .unwrap()
//                 .first()
//                 .unwrap();

//             let features = vk::PhysicalDeviceFeatures {
//                 ..Default::default()
//             };
//             let queue_family_index = instance
//                 .get_physical_device_queue_family_properties(physical_device)
//                 .iter()
//                 .enumerate()
//                 .find_map(|(index, info)| {
//                     if info.queue_flags.contains(vk::QueueFlags::GRAPHICS) {
//                         return Some(index);
//                     }
//                     None
//                 })
//                 .unwrap();
//             let device_queue_create_info = vk::DeviceQueueCreateInfo::default();

//             let device_ext = [
//                 ash::khr::swapchain::NAME.as_ptr(),
//                 CStr::from_bytes_with_nul_unchecked(b"VK_KHR_external_memory_fd\0").as_ptr(),
//             ];

//             let device_create_info = vk::DeviceCreateInfo::default()
//                 .queue_create_infos(std::slice::from_ref(&device_queue_create_info))
//                 .enabled_extension_names(&device_ext)
//                 .enabled_features(&features);

//             let device = instance
//                 .create_device(physical_device, &device_create_info, None)
//                 .unwrap();

//             let queue = device.get_device_queue(queue_family_index.try_into().unwrap(), 0);

//             let surface_loader = surface::Instance::new(&entry, &instance);
//             let surface = ash_window::create_surface(
//                 &entry,
//                 &instance,
//                 display_handle.as_raw(),
//                 window_handle.as_raw(),
//                 None,
//             )
//             .unwrap();

//             let surface_format = *surface_loader
//                 .get_physical_device_surface_formats(physical_device, surface)
//                 .unwrap()
//                 .first()
//                 .unwrap();

//             let surface_capabilities = surface_loader
//                 .get_physical_device_surface_capabilities(physical_device, surface)
//                 .unwrap();

//             let swap_chain_extent = vk::Extent2D {
//                 width: 1024,
//                 height: 1024,
//             };
//             let swap_chain_loader = swapchain::Device::new(&instance, &device);
//             let swap_chain_crete_info = SwapchainCreateInfoKHR::default()
//                 .surface(surface)
//                 .min_image_count(surface_capabilities.min_image_count + 1)
//                 .image_format(surface_format.format)
//                 .image_color_space(surface_format.color_space)
//                 .image_extent(swap_chain_extent)
//                 .image_usage(vk::ImageUsageFlags::COLOR_ATTACHMENT)
//                 .image_sharing_mode(vk::SharingMode::EXCLUSIVE)
//                 .pre_transform(vk::SurfaceTransformFlagsKHR::IDENTITY)
//                 .composite_alpha(vk::CompositeAlphaFlagsKHR::OPAQUE)
//                 .present_mode(vk::PresentModeKHR::MAILBOX)
//                 .clipped(true)
//                 .image_array_layers(1);

//             let swap_chain =swap_chain_loader.create_swapchain(&swap_chain_crete_info, None);

//             self.window = Some(new_window);
//             self.surface = Some(surface);
//         }
//     }

//     fn window_event(
//         &mut self,
//         event_loop: &ActiveEventLoop,
//         _window_id: winit::window::WindowId,
//         event: WindowEvent,
//     ) {
//         match event {
//             WindowEvent::CloseRequested => {
//                 println!("ばいばい");
//                 event_loop.exit();
//             }

//             WindowEvent::RedrawRequested => {
//                 if let Some(w) = self.window.as_ref() {
//                     w.request_redraw();
//                 }
//             }
//             _ => (),
//         }
//     }

//     fn about_to_wait(&mut self, event_loop: &ActiveEventLoop) {
//         // if self.window.is_none() {
//         //     event_loop.exit();
//         // }
//     }
// }

// #[allow(dead_code)]

// Vulkan triangle rendering with ash and winit

// use ash::vk::{
//     self, CopyImageInfo2, Extent3D, Format, ImageCopy, ImageCopy2, ImageCreateFlags, ImageCreateInfo, ImageLayout, ImageTiling, ImageType, ImageUsageFlags, ImportMemoryFdInfoKHR, MemoryAllocateInfo, SampleCountFlags, SharingMode
// };
// use raw_window_handle::{HasDisplayHandle, HasWindowHandle};
// use rustix::process::{ForeignRawFd, Pid, PidfdFlags, PidfdGetfdFlags};
// use std::ffi::{CStr, CString};
// use std::os::fd::AsRawFd;
// use winit::application::ApplicationHandler;
// use winit::event::WindowEvent;
// use winit::event_loop::{ActiveEventLoop, ControlFlow, EventLoop};
// use winit::window::{Window, WindowId};

// const WIDTH: u32 = 1024;
// const HEIGHT: u32 = 1024;

// struct VulkanContext {
//     entry: ash::Entry,
//     instance: ash::Instance,
//     surface_loader: ash::khr::surface::Instance,
//     surface: vk::SurfaceKHR,
//     physical_device: vk::PhysicalDevice,
//     device: ash::Device,
//     graphics_queue: vk::Queue,
//     present_queue: vk::Queue,
//     graphics_queue_index: u32,
//     present_queue_index: u32,
//     swapchain_loader: ash::khr::swapchain::Device,
//     swapchain: vk::SwapchainKHR,
//     swapchain_images: Vec<vk::Image>,
//     swapchain_image_views: Vec<vk::ImageView>,
//     swapchain_extent: vk::Extent2D,
//     swapchain_format: vk::Format,
//     render_pass: vk::RenderPass,
//     // pipeline_layout: vk::PipelineLayout,
//     // pipeline: vk::Pipeline,
//     framebuffers: Vec<vk::Framebuffer>,
//     command_pool: vk::CommandPool,
//     command_buffers: Vec<vk::CommandBuffer>,
//     image_available_semaphore: vk::Semaphore,
//     render_finished_semaphore: vk::Semaphore,
//     in_flight_fence: vk::Fence,
//     from_shared_memory: vk::DeviceMemory,
//     from_shared_texture: vk::Image,
// }

// impl VulkanContext {
//     unsafe fn new(window: &Window) -> Self {
//         unsafe {
//             let entry = ash::Entry::load().unwrap();

//             // インスタンス作成
//             let app_name = CString::new("Vulkan Triangle").unwrap();
//             let engine_name = CString::new("No Engine").unwrap();
//             let app_info = vk::ApplicationInfo::default()
//                 .application_name(&app_name)
//                 .application_version(vk::make_api_version(0, 1, 0, 0))
//                 .engine_name(&engine_name)
//                 .engine_version(vk::make_api_version(0, 1, 0, 0))
//                 .api_version(vk::make_api_version(0, 1, 0, 0));

//             let extension_names = ash_window::enumerate_required_extensions(
//                 window.display_handle().unwrap().as_raw(),
//             )
//             .unwrap()
//             .to_vec();

//             let create_info = vk::InstanceCreateInfo::default()
//                 .application_info(&app_info)
//                 .enabled_extension_names(&extension_names);

//             let instance = entry.create_instance(&create_info, None).unwrap();

//             // サーフェス作成
//             let surface_loader = ash::khr::surface::Instance::new(&entry, &instance);
//             let surface = ash_window::create_surface(
//                 &entry,
//                 &instance,
//                 window.display_handle().unwrap().as_raw(),
//                 window.window_handle().unwrap().as_raw(),
//                 None,
//             )
//             .unwrap();

//             // 物理デバイス選択
//             let physical_devices = instance.enumerate_physical_devices().unwrap();
//             let physical_device = physical_devices[0];

//             // キューファミリー検索
//             let queue_families =
//                 instance.get_physical_device_queue_family_properties(physical_device);
//             let graphics_queue_index = queue_families
//                 .iter()
//                 .enumerate()
//                 .find(|(_, qf)| qf.queue_flags.contains(vk::QueueFlags::GRAPHICS))
//                 .map(|(i, _)| i as u32)
//                 .unwrap();

//             let present_queue_index = (0..queue_families.len() as u32)
//                 .find(|&i| {
//                     surface_loader
//                         .get_physical_device_surface_support(physical_device, i, surface)
//                         .unwrap()
//                 })
//                 .unwrap();

//             // 論理デバイス作成
//             let queue_priorities = [1.0];
//             let mut queue_create_infos = vec![
//                 vk::DeviceQueueCreateInfo::default()
//                     .queue_family_index(graphics_queue_index)
//                     .queue_priorities(&queue_priorities),
//             ];

//             if graphics_queue_index != present_queue_index {
//                 queue_create_infos.push(
//                     vk::DeviceQueueCreateInfo::default()
//                         .queue_family_index(present_queue_index)
//                         .queue_priorities(&queue_priorities),
//                 );
//             }

//             let device_extension_names = [
//                 ash::khr::swapchain::NAME.as_ptr(),
//                 CStr::from_bytes_with_nul_unchecked(b"VK_KHR_external_memory_fd\0").as_ptr(),
//             ];
//             let device_create_info = vk::DeviceCreateInfo::default()
//                 .queue_create_infos(&queue_create_infos)
//                 .enabled_extension_names(&device_extension_names);

//             let device = instance
//                 .create_device(physical_device, &device_create_info, None)
//                 .unwrap();

//             let graphics_queue = device.get_device_queue(graphics_queue_index, 0);
//             let present_queue = device.get_device_queue(present_queue_index, 0);

//             // スワップチェーン作成
//             let surface_capabilities = surface_loader
//                 .get_physical_device_surface_capabilities(physical_device, surface)
//                 .unwrap();
//             let surface_formats = surface_loader
//                 .get_physical_device_surface_formats(physical_device, surface)
//                 .unwrap();
//             let surface_format = surface_formats[0];

//             let swapchain_extent = vk::Extent2D {
//                 width: WIDTH,
//                 height: HEIGHT,
//             };

//             let swapchain_loader = ash::khr::swapchain::Device::new(&instance, &device);
//             let swapchain_create_info = vk::SwapchainCreateInfoKHR::default()
//                 .surface(surface)
//                 .min_image_count(surface_capabilities.min_image_count + 1)
//                 .image_format(surface_format.format)
//                 .image_color_space(surface_format.color_space)
//                 .image_extent(swapchain_extent)
//                 .image_array_layers(1)
//                 .image_usage(
//                     vk::ImageUsageFlags::COLOR_ATTACHMENT | vk::ImageUsageFlags::TRANSFER_DST,
//                 )
//                 .image_sharing_mode(vk::SharingMode::EXCLUSIVE)
//                 .pre_transform(surface_capabilities.current_transform)
//                 .composite_alpha(vk::CompositeAlphaFlagsKHR::OPAQUE)
//                 .present_mode(vk::PresentModeKHR::FIFO)
//                 .clipped(true);

//             let swapchain = swapchain_loader
//                 .create_swapchain(&swapchain_create_info, None)
//                 .unwrap();

//             let swapchain_images = swapchain_loader.get_swapchain_images(swapchain).unwrap();

//             // イメージビュー作成
//             let swapchain_image_views: Vec<_> = swapchain_images
//                 .iter()
//                 .map(|&image| {
//                     let create_info = vk::ImageViewCreateInfo::default()
//                         .image(image)
//                         .view_type(vk::ImageViewType::TYPE_2D)
//                         .format(surface_format.format)
//                         .subresource_range(vk::ImageSubresourceRange {
//                             aspect_mask: vk::ImageAspectFlags::COLOR,
//                             base_mip_level: 0,
//                             level_count: 1,
//                             base_array_layer: 0,
//                             layer_count: 1,
//                         });
//                     device.create_image_view(&create_info, None).unwrap()
//                 })
//                 .collect();

//             // レンダーパス作成
//             let color_attachment = vk::AttachmentDescription::default()
//                 .format(surface_format.format)
//                 .samples(vk::SampleCountFlags::TYPE_1)
//                 .load_op(vk::AttachmentLoadOp::CLEAR)
//                 .store_op(vk::AttachmentStoreOp::STORE)
//                 .stencil_load_op(vk::AttachmentLoadOp::DONT_CARE)
//                 .stencil_store_op(vk::AttachmentStoreOp::DONT_CARE)
//                 .initial_layout(vk::ImageLayout::UNDEFINED)
//                 .final_layout(vk::ImageLayout::PRESENT_SRC_KHR);

//             let color_attachment_ref = vk::AttachmentReference::default()
//                 .attachment(0)
//                 .layout(vk::ImageLayout::COLOR_ATTACHMENT_OPTIMAL);

//             let subpass = vk::SubpassDescription::default()
//                 .pipeline_bind_point(vk::PipelineBindPoint::GRAPHICS)
//                 .color_attachments(std::slice::from_ref(&color_attachment_ref));

//             let dependency = vk::SubpassDependency::default()
//                 .src_subpass(vk::SUBPASS_EXTERNAL)
//                 .dst_subpass(0)
//                 .src_stage_mask(vk::PipelineStageFlags::COLOR_ATTACHMENT_OUTPUT)
//                 .src_access_mask(vk::AccessFlags::empty())
//                 .dst_stage_mask(vk::PipelineStageFlags::COLOR_ATTACHMENT_OUTPUT)
//                 .dst_access_mask(vk::AccessFlags::COLOR_ATTACHMENT_WRITE);

//             let render_pass_create_info = vk::RenderPassCreateInfo::default()
//                 .attachments(std::slice::from_ref(&color_attachment))
//                 .subpasses(std::slice::from_ref(&subpass))
//                 .dependencies(std::slice::from_ref(&dependency));

//             let render_pass = device
//                 .create_render_pass(&render_pass_create_info, None)
//                 .unwrap();

//             // シェーダーモジュール作成
//             // let vert_shader_module = Self::create_shader_module(&device, VERTEX_SHADER);
//             // let frag_shader_module = Self::create_shader_module(&device, FRAGMENT_SHADER);

//             // let entry_point = CString::new("main").unwrap();
//             // let vert_stage_info = vk::PipelineShaderStageCreateInfo::default()
//             //     .stage(vk::ShaderStageFlags::VERTEX)
//             //     .module(vert_shader_module)
//             //     .name(&entry_point);

//             // let frag_stage_info = vk::PipelineShaderStageCreateInfo::default()
//             //     .stage(vk::ShaderStageFlags::FRAGMENT)
//             //     .module(frag_shader_module)
//             //     .name(&entry_point);

//             // let shader_stages = [vert_stage_info, frag_stage_info];

//             // パイプライン作成
//             // let vertex_input_info = vk::PipelineVertexInputStateCreateInfo::default();

//             // let input_assembly = vk::PipelineInputAssemblyStateCreateInfo::default()
//             //     .topology(vk::PrimitiveTopology::TRIANGLE_LIST)
//             //     .primitive_restart_enable(false);

//             // let viewport = vk::Viewport {
//             //     x: 0.0,
//             //     y: 0.0,
//             //     width: swapchain_extent.width as f32,
//             //     height: swapchain_extent.height as f32,
//             //     min_depth: 0.0,
//             //     max_depth: 1.0,
//             // };

//             // let scissor = vk::Rect2D {
//             //     offset: vk::Offset2D { x: 0, y: 0 },
//             //     extent: swapchain_extent,
//             // };

//             // let viewport_state = vk::PipelineViewportStateCreateInfo::default()
//             //     .viewports(std::slice::from_ref(&viewport))
//             //     .scissors(std::slice::from_ref(&scissor));

//             // let rasterizer = vk::PipelineRasterizationStateCreateInfo::default()
//             //     .depth_clamp_enable(false)
//             //     .rasterizer_discard_enable(false)
//             //     .polygon_mode(vk::PolygonMode::FILL)
//             //     .line_width(1.0)
//             //     .cull_mode(vk::CullModeFlags::BACK)
//             //     .front_face(vk::FrontFace::CLOCKWISE)
//             //     .depth_bias_enable(false);

//             // let multisampling = vk::PipelineMultisampleStateCreateInfo::default()
//             //     .sample_shading_enable(false)
//             //     .rasterization_samples(vk::SampleCountFlags::TYPE_1);

//             // let color_blend_attachment = vk::PipelineColorBlendAttachmentState::default()
//             //     .color_write_mask(vk::ColorComponentFlags::RGBA)
//             //     .blend_enable(false);

//             // let color_blending = vk::PipelineColorBlendStateCreateInfo::default()
//             //     .logic_op_enable(false)
//             //     .attachments(std::slice::from_ref(&color_blend_attachment));

//             // let pipeline_layout_info = vk::PipelineLayoutCreateInfo::default();
//             // let pipeline_layout = device
//             //     .create_pipeline_layout(&pipeline_layout_info, None)
//             //     .unwrap();

//             // let pipeline_info = vk::GraphicsPipelineCreateInfo::default()
//             //     .stages(&shader_stages)
//             //     .vertex_input_state(&vertex_input_info)
//             //     .input_assembly_state(&input_assembly)
//             //     .viewport_state(&viewport_state)
//             //     .rasterization_state(&rasterizer)
//             //     .multisample_state(&multisampling)
//             //     .color_blend_state(&color_blending)
//             //     .layout(pipeline_layout)
//             //     .render_pass(render_pass)
//             //     .subpass(0);

//             // let pipeline = device
//             //     .create_graphics_pipelines(vk::PipelineCache::null(), &[pipeline_info], None)
//             //     .unwrap()[0];

//             // device.destroy_shader_module(vert_shader_module, None);
//             // device.destroy_shader_module(frag_shader_module, None);

//             // フレームバッファ作成
//             let framebuffers: Vec<_> = swapchain_image_views
//                 .iter()
//                 .map(|&image_view| {
//                     let attachments = [image_view];
//                     let framebuffer_info = vk::FramebufferCreateInfo::default()
//                         .render_pass(render_pass)
//                         .attachments(&attachments)
//                         .width(swapchain_extent.width)
//                         .height(swapchain_extent.height)
//                         .layers(1);
//                     device.create_framebuffer(&framebuffer_info, None).unwrap()
//                 })
//                 .collect();

//             // コマンドプール作成
//             let command_pool_info = vk::CommandPoolCreateInfo::default()
//                 .queue_family_index(graphics_queue_index)
//                 .flags(vk::CommandPoolCreateFlags::RESET_COMMAND_BUFFER);

//             let command_pool = device
//                 .create_command_pool(&command_pool_info, None)
//                 .unwrap();

//             // コマンドバッファ作成
//             let command_buffer_allocate_info = vk::CommandBufferAllocateInfo::default()
//                 .command_pool(command_pool)
//                 .level(vk::CommandBufferLevel::PRIMARY)
//                 .command_buffer_count(framebuffers.len() as u32);

//             let command_buffers = device
//                 .allocate_command_buffers(&command_buffer_allocate_info)
//                 .unwrap();

//             // 同期オブジェクト作成
//             let semaphore_info = vk::SemaphoreCreateInfo::default();
//             let fence_info = vk::FenceCreateInfo::default().flags(vk::FenceCreateFlags::SIGNALED);

//             let image_available_semaphore = device.create_semaphore(&semaphore_info, None).unwrap();
//             let render_finished_semaphore = device.create_semaphore(&semaphore_info, None).unwrap();
//             let in_flight_fence = device.create_fence(&fence_info, None).unwrap();

//             // Import!!!

//             let from_shared_texture_create_info = ImageCreateInfo::default()
//                 .image_type(ImageType::TYPE_2D)
//                 .extent(Extent3D {
//                     height: 1024,
//                     width: 1024,
//                     depth: 1,
//                 })
//                 .mip_levels(1)
//                 .array_layers(1)
//                 .format(Format::R8G8B8A8_UNORM)
//                 .samples(SampleCountFlags::TYPE_1)
//                 .tiling(ImageTiling::OPTIMAL)
//                 .usage(ImageUsageFlags::TRANSFER_SRC)
//                 .sharing_mode(SharingMode::EXCLUSIVE)
//                 .flags(ImageCreateFlags::default());
//             let from_shared_texture = device
//                 .create_image(&from_shared_texture_create_info, None)
//                 .unwrap();

//             let fd = get_fd_from_args();

//             let mut import_memory_info = ImportMemoryFdInfoKHR::default().fd(fd.as_raw_fd());
//             std::mem::forget(fd);

//             let import_shared_memory_info = MemoryAllocateInfo::default()
//                 .allocation_size(1024 * 1024 * 4)
//                 .memory_type_index(Self::find_memory_type(
//                     device.get_image_memory_requirements(from_shared_texture),
//                     instance.get_physical_device_memory_properties(physical_device),
//                     vk::MemoryPropertyFlags::DEVICE_LOCAL,
//                 ))
//                 .push_next(&mut import_memory_info);
//             let from_shared_memory = device
//                 .allocate_memory(&import_shared_memory_info, None)
//                 .unwrap();

//             device
//                 .bind_image_memory(from_shared_texture, from_shared_memory, 0)
//                 .unwrap();

//             VulkanContext {
//                 entry,
//                 instance,
//                 surface_loader,
//                 surface,
//                 physical_device,
//                 device,
//                 graphics_queue,
//                 present_queue,
//                 graphics_queue_index,
//                 present_queue_index,
//                 swapchain_loader,
//                 swapchain,
//                 swapchain_images,
//                 swapchain_image_views,
//                 swapchain_extent,
//                 swapchain_format: surface_format.format,
//                 render_pass,
//                 // pipeline_layout,
//                 // pipeline,
//                 framebuffers,
//                 command_pool,
//                 command_buffers,
//                 image_available_semaphore,
//                 render_finished_semaphore,
//                 in_flight_fence,

//                 from_shared_memory,
//                 from_shared_texture,
//             }
//         }
//     }
//     unsafe fn create_shader_module(device: &ash::Device, code: &[u8]) -> vk::ShaderModule {
//         unsafe {
//             let code_aligned = ash::util::read_spv(&mut std::io::Cursor::new(code)).unwrap();
//             let create_info = vk::ShaderModuleCreateInfo::default().code(&code_aligned);
//             device.create_shader_module(&create_info, None).unwrap()
//         }
//     }

//     unsafe fn draw_frame(&mut self) {
//         unsafe {
//             self.device
//                 .wait_for_fences(&[self.in_flight_fence], true, u64::MAX)
//                 .unwrap();
//             self.device.reset_fences(&[self.in_flight_fence]).unwrap();

//             let (image_index, _) = self
//                 .swapchain_loader
//                 .acquire_next_image(
//                     self.swapchain,
//                     u64::MAX,
//                     self.image_available_semaphore,
//                     vk::Fence::null(),
//                 )
//                 .unwrap();

//             let command_buffer = self.command_buffers[image_index as usize];

//             self.device
//                 .reset_command_buffer(command_buffer, vk::CommandBufferResetFlags::empty())
//                 .unwrap();

//             let begin_info = vk::CommandBufferBeginInfo::default();
//             self.device
//                 .begin_command_buffer(command_buffer, &begin_info)
//                 .unwrap();

//             // let clear_value = vk::ClearValue {
//             //     color: vk::ClearColorValue {
//             //         float32: [0.0, 0.0, 0.0, 1.0],
//             //     },
//             // };

//             // let render_pass_info = vk::RenderPassBeginInfo::default()
//             //     .render_pass(self.render_pass)
//             //     .framebuffer(self.framebuffers[image_index as usize])
//             //     .render_area(vk::Rect2D {
//             //         offset: vk::Offset2D { x: 0, y: 0 },
//             //         extent: self.swapchain_extent,
//             //     })
//             //     .clear_values(std::slice::from_ref(&clear_value));

//             // self.device.cmd_begin_render_pass(
//             //     command_buffer,
//             //     &render_pass_info,
//             //     vk::SubpassContents::INLINE,
//             // );

//             // self.device
//             //     .cmd_bind_pipeline(command_buffer, vk::PipelineBindPoint::GRAPHICS, self.pipeline);

//             // self.device.cmd_draw(command_buffer, 3, 1, 0, 0);

//             // self.device.cmd_end_render_pass(command_buffer);

//             // let rg = [ImageCopy2::default().extent(Extent3D {
//             //     width: 1024,
//             //     height: 1024,
//             //     depth: 1,
//             // })];
//             // let copy_info = CopyImageInfo2::default()
//             //     .src_image(self.from_shared_texture)
//             //     .src_image_layout(ImageLayout::TRANSFER_SRC_OPTIMAL)//     //https://github.com/adrien-ben/vulkan-tutorial-rs/blob/3b3e61b9d98783aa45c3ed46bb6f61d04142e045/src/main.rs#L1882-L1897
//     fn find_memory_type(
//         requirements: vk::MemoryRequirements,
//         mem_properties: vk::PhysicalDeviceMemoryProperties,
//         required_properties: vk::MemoryPropertyFlags,
//     ) -> u32 {
//         for i in 0..mem_properties.memory_type_count {
//             if requirements.memory_type_bits & (1 << i) != 0
//                 && mem_properties.memory_types[i as usize]
//                     .property_flags
//                     .contains(required_properties)
//             {
//                 return i;
//             }
//         }
//         panic!("Failed to find suitable memory type.")
//     }
//             //     .dst_image(self.swapchain_images[image_index as usize])
//             //     .dst_image_layout(ImageLayout::TRANSFER_DST_OPTIMAL)
//             //     .regions(&rg);
//             // self.device.cmd_copy_image2(command_buffer, &copy_info);

//             let rg = [ImageCopy::default().extent(Extent3D {
//                 width: 1024,
//                 height: 1024,
//                 depth: 1,
//             })];
//             self.device.cmd_copy_image(
//                 command_buffer,
//                 self.from_shared_texture,
//                 ImageLayout::TRANSFER_SRC_OPTIMAL,
//                 self.swapchain_images[image_index as usize],
//                 ImageLayout::TRANSFER_DST_OPTIMAL,
//                 &rg,
//             );
//             self.device.end_command_buffer(command_buffer).unwrap();

//             let wait_semaphores = [self.image_available_semaphore];
//             let wait_stages = [vk::PipelineStageFlags::COLOR_ATTACHMENT_OUTPUT];
//             let signal_semaphores = [self.render_finished_semaphore];
//             let command_buffers = [command_buffer];

//             let submit_info = vk::SubmitInfo::default()
//                 .wait_semaphores(&wait_semaphores)
//                 .wait_dst_stage_mask(&wait_stages)
//                 .command_buffers(&command_buffers)
//                 .signal_semaphores(&signal_semaphores);

//             self.device
//                 .queue_submit(self.graphics_queue, &[submit_info], self.in_flight_fence)
//                 .unwrap();

//             let swapchains = [self.swapchain];
//             let image_indices = [image_index];
//             let present_info = vk::PresentInfoKHR::default()
//                 .wait_semaphores(&signal_semaphores)
//                 .swapchains(&swapchains)
//                 .image_indices(&image_indices);

//             self.swapchain_loader
//                 .queue_present(self.present_queue, &present_info)
//                 .unwrap();
//         }
//     }
// }

// impl Drop for VulkanContext {
//     fn drop(&mut self) {
//         unsafe {
//             self.device.device_wait_idle().unwrap();

//             self.device
//                 .destroy_semaphore(self.image_available_semaphore, None);
//             self.device
//                 .destroy_semaphore(self.render_finished_semaphore, None);
//             self.device.destroy_fence(self.in_flight_fence, None);

//             self.device.destroy_command_pool(self.command_pool, None);

//             for &framebuffer in &self.framebuffers {
//                 self.device.destroy_framebuffer(framebuffer, None);
//             }

//             // self.device.destroy_pipeline(self.pipeline, None);
//             // self.device
//             //     .destroy_pipeline_layout(self.pipeline_layout, None);
//             self.device.destroy_render_pass(self.render_pass, None);

//             for &image_view in &self.swapchain_image_views {
//                 self.device.destroy_image_view(image_view, None);
//             }

//             self.swapchain_loader
//                 .destroy_swapchain(self.swapchain, None);
//             self.device.destroy_device(None);
//             self.surface_loader.destroy_surface(self.surface, None);
//             self.instance.destroy_instance(None);
//         }
//     }
// }

// struct App {
//     window: Option<Window>,
//     vulkan_context: Option<VulkanContext>,
// }

// impl Default for App {
//     fn default() -> Self {
//         Self {
//             window: None,
//             vulkan_context: None,
//         }
//     }
// }

// impl ApplicationHandler for App {
//     fn resumed(&mut self, event_loop: &ActiveEventLoop) {
//         let window = event_loop
//             .create_window(
//                 Window::default_attributes()
//                     .with_title("Vulkan fd Test")
//                     .with_inner_size(winit::dpi::LogicalSize::new(WIDTH, HEIGHT)),
//             )
//             .unwrap();

//         self.vulkan_context = Some(unsafe { VulkanContext::new(&window) });
//         self.window = Some(window);
//     }

//     fn window_event(&mut self, event_loop: &ActiveEventLoop, _: WindowId, event: WindowEvent) {
//         match event {
//             WindowEvent::CloseRequested => {
//                 println!("Close was requested; stopping");
//                 event_loop.exit();
//             }
//             WindowEvent::RedrawRequested => {
//                 if let Some(ref mut vulkan_context) = self.vulkan_context {
//                     unsafe {
//                         vulkan_context.draw_frame();
//                     }
//                 }
//             }
//             _ => (),
//         }
//     }
// }

// fn main() {
//     let event_loop = EventLoop::new().unwrap();
//     event_loop.set_control_flow(ControlFlow::Poll);

//     let mut app = App::default();
//     event_loop.run_app(&mut app).unwrap();
// }

use core::slice;
use std::{
    ffi::{CStr, CString},
    os::fd::AsRawFd,
};

use ash::vk::{
    self, BufferCreateFlags, BufferCreateInfo, BufferImageCopy, BufferUsageFlags, Extent3D, Fence,
    Format, ImageCreateFlags, ImageCreateInfo, ImageLayout, ImageTiling, ImageType,
    ImageUsageFlags, ImportMemoryFdInfoKHR, MemoryAllocateInfo, MemoryMapFlags, SampleCountFlags,
    SharingMode,
};
use rustix::process::{ForeignRawFd, Pid, PidfdFlags, PidfdGetfdFlags};

fn get_fd_from_args() -> std::os::unix::prelude::OwnedFd {
    let args: Vec<_> = std::env::args().collect();

    let pid_raw: i32 = args[1].parse().unwrap();
    let fd_foreign: i32 = args[2].parse().unwrap();

    println!("pid:{},fd_foreign:{}", pid_raw, fd_foreign);

    let pid_fd =
        rustix::process::pidfd_open(Pid::from_raw(pid_raw).unwrap(), PidfdFlags::empty()).unwrap();
    let this_fd = rustix::process::pidfd_getfd(
        pid_fd,
        ForeignRawFd::from(fd_foreign),
        PidfdGetfdFlags::empty(),
    )
    .unwrap();

    println!("owned new fd:{}", this_fd.as_raw_fd());

    this_fd
}
fn main() {
    unsafe {
        let entry = ash::Entry::load().unwrap();

        // インスタンス作成
        let app_name = CString::new("Vulkan Triangle").unwrap();
        let engine_name = CString::new("No Engine").unwrap();
        let app_info = vk::ApplicationInfo::default()
            .application_name(&app_name)
            .application_version(vk::make_api_version(0, 1, 0, 0))
            .engine_name(&engine_name)
            .engine_version(vk::make_api_version(0, 1, 0, 0))
            .api_version(vk::make_api_version(0, 1, 0, 0));

        let create_info = vk::InstanceCreateInfo::default().application_info(&app_info);

        let instance = entry.create_instance(&create_info, None).unwrap();

        // 物理デバイス選択
        let physical_devices = instance.enumerate_physical_devices().unwrap();
        let physical_device = physical_devices[0];

        // キューファミリー検索
        let queue_families = instance.get_physical_device_queue_family_properties(physical_device);
        let graphics_queue_index = queue_families
            .iter()
            .enumerate()
            .find(|(_, qf)| qf.queue_flags.contains(vk::QueueFlags::GRAPHICS))
            .map(|(i, _)| i as u32)
            .unwrap();

        // 論理デバイス作成
        let queue_priorities = [1.0];
        let mut queue_create_infos = vec![
            vk::DeviceQueueCreateInfo::default()
                .queue_family_index(graphics_queue_index)
                .queue_priorities(&queue_priorities),
        ];

        let device_extension_names =
            [CStr::from_bytes_with_nul_unchecked(b"VK_KHR_external_memory_fd\0").as_ptr()];
        let device_create_info = vk::DeviceCreateInfo::default()
            .queue_create_infos(&queue_create_infos)
            .enabled_extension_names(&device_extension_names);

        let device = instance
            .create_device(physical_device, &device_create_info, None)
            .unwrap();

        let graphics_queue = device.get_device_queue(graphics_queue_index, 0);

        let command_pool_info = vk::CommandPoolCreateInfo::default()
            .queue_family_index(graphics_queue_index)
            .flags(vk::CommandPoolCreateFlags::RESET_COMMAND_BUFFER);

        let command_pool = device
            .create_command_pool(&command_pool_info, None)
            .unwrap();

        // コマンドバッファ作成
        let command_buffer_allocate_info = vk::CommandBufferAllocateInfo::default()
            .command_pool(command_pool)
            .level(vk::CommandBufferLevel::PRIMARY)
            .command_buffer_count(1 as u32);

        let command_buffers = device
            .allocate_command_buffers(&command_buffer_allocate_info)
            .unwrap();

        let command_buffer = command_buffers[0];

        // Import!!!

        let from_shared_texture_create_info = ImageCreateInfo::default()
            .image_type(ImageType::TYPE_2D)
            .extent(Extent3D {
                height: 1024,
                width: 1024,
                depth: 1,
            })
            .mip_levels(1)
            .array_layers(1)
            .format(Format::R8G8B8A8_UNORM)
            .samples(SampleCountFlags::TYPE_1)
            .tiling(ImageTiling::OPTIMAL)
            .usage(ImageUsageFlags::TRANSFER_SRC)
            .sharing_mode(SharingMode::EXCLUSIVE)
            .flags(ImageCreateFlags::default());
        let from_shared_texture = device
            .create_image(&from_shared_texture_create_info, None)
            .unwrap();

        let fd = get_fd_from_args();

        let mut import_memory_info = ImportMemoryFdInfoKHR::default().fd(fd.as_raw_fd());
        std::mem::forget(fd);

        let import_shared_memory_info = MemoryAllocateInfo::default()
            .allocation_size(1024 * 1024 * 4)
            .memory_type_index(find_memory_type(
                device.get_image_memory_requirements(from_shared_texture),
                instance.get_physical_device_memory_properties(physical_device),
                vk::MemoryPropertyFlags::DEVICE_LOCAL,
            ))
            .push_next(&mut import_memory_info);
        let from_shared_memory = device
            .allocate_memory(&import_shared_memory_info, None)
            .unwrap();

        device
            .bind_image_memory(from_shared_texture, from_shared_memory, 0)
            .unwrap();
        let tex_size = 1024 * 1024 * 4;
        let buf_info = BufferCreateInfo::default()
            .flags(BufferCreateFlags::SPARSE_BINDING)
            .usage(BufferUsageFlags::TRANSFER_DST)
            .size(tex_size)
            .sharing_mode(SharingMode::EXCLUSIVE);
        let copy_buf = device.create_buffer(&buf_info, None).unwrap();
        let buf_mem_alloc_info = MemoryAllocateInfo::default()
            .allocation_size(tex_size)
            .memory_type_index(find_memory_type(
                device.get_image_memory_requirements(from_shared_texture),
                instance.get_physical_device_memory_properties(physical_device),
                vk::MemoryPropertyFlags::DEVICE_LOCAL | vk::MemoryPropertyFlags::HOST_VISIBLE,
            ));
        let buf_memory = device.allocate_memory(&buf_mem_alloc_info, None).unwrap();

        device.cmd_copy_image_to_buffer(
            command_buffer,
            from_shared_texture,
            ImageLayout::TRANSFER_DST_OPTIMAL,
            copy_buf,
            &[BufferImageCopy::default()
                .buffer_offset(0)
                .buffer_image_height(1024)
                .buffer_row_length(1024)
                .image_extent(Extent3D {
                    width: 1024,
                    height: 1024,
                    depth: 1,
                })],
        );

        let submit_info = vk::SubmitInfo::default().command_buffers(&command_buffers);
        device
            .queue_submit(graphics_queue, &[submit_info], Fence::null())
            .unwrap();

        device.bind_buffer_memory(copy_buf, buf_memory, 0).unwrap();
        let mapped_memory = device
            .map_memory(buf_memory, 0, tex_size, MemoryMapFlags::default())
            .unwrap();


        image::save_buffer(
            "out.png",
            slice::from_raw_parts(mapped_memory as *const u8, tex_size.try_into().unwrap()),
            1024,
            1024,
            image::ColorType::Rgba8,
        ).unwrap();
    }
}

//https://github.com/adrien-ben/vulkan-tutorial-rs/blob/3b3e61b9d98783aa45c3ed46bb6f61d04142e045/src/main.rs#L1882-L1897
fn find_memory_type(
    requirements: vk::MemoryRequirements,
    mem_properties: vk::PhysicalDeviceMemoryProperties,
    required_properties: vk::MemoryPropertyFlags,
) -> u32 {
    for i in 0..mem_properties.memory_type_count {
        if requirements.memory_type_bits & (1 << i) != 0
            && mem_properties.memory_types[i as usize]
                .property_flags
                .contains(required_properties)
        {
            return i;
        }
    }
    panic!("Failed to find suitable memory type.")
}
